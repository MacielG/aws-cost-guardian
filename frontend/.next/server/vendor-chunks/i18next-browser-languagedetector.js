"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/i18next-browser-languagedetector";
exports.ids = ["vendor-chunks/i18next-browser-languagedetector"];
exports.modules = {

/***/ "(rsc)/../node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Browser)\n/* harmony export */ });\nconst { slice, forEach } = [];\nfunction defaults(obj) {\n    forEach.call(slice.call(arguments, 1), (source)=>{\n        if (source) {\n            for(const prop in source){\n                if (obj[prop] === undefined) obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n}\nfunction hasXSS(input) {\n    if (typeof input !== \"string\") return false;\n    // Common XSS attack patterns\n    const xssPatterns = [\n        /<\\s*script.*?>/i,\n        /<\\s*\\/\\s*script\\s*>/i,\n        /<\\s*img.*?on\\w+\\s*=/i,\n        /<\\s*\\w+\\s*on\\w+\\s*=.*?>/i,\n        /javascript\\s*:/i,\n        /vbscript\\s*:/i,\n        /expression\\s*\\(/i,\n        /eval\\s*\\(/i,\n        /alert\\s*\\(/i,\n        /document\\.cookie/i,\n        /document\\.write\\s*\\(/i,\n        /window\\.location/i,\n        /innerHTML/i\n    ];\n    return xssPatterns.some((pattern)=>pattern.test(input));\n}\n// eslint-disable-next-line no-control-regex\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nconst serializeCookie = function(name, val) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n        path: \"/\"\n    };\n    const opt = options;\n    const value = encodeURIComponent(val);\n    let str = `${name}=${value}`;\n    if (opt.maxAge > 0) {\n        const maxAge = opt.maxAge - 0;\n        if (Number.isNaN(maxAge)) throw new Error(\"maxAge should be a Number\");\n        str += `; Max-Age=${Math.floor(maxAge)}`;\n    }\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError(\"option domain is invalid\");\n        }\n        str += `; Domain=${opt.domain}`;\n    }\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError(\"option path is invalid\");\n        }\n        str += `; Path=${opt.path}`;\n    }\n    if (opt.expires) {\n        if (typeof opt.expires.toUTCString !== \"function\") {\n            throw new TypeError(\"option expires is invalid\");\n        }\n        str += `; Expires=${opt.expires.toUTCString()}`;\n    }\n    if (opt.httpOnly) str += \"; HttpOnly\";\n    if (opt.secure) str += \"; Secure\";\n    if (opt.sameSite) {\n        const sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n        switch(sameSite){\n            case true:\n                str += \"; SameSite=Strict\";\n                break;\n            case \"lax\":\n                str += \"; SameSite=Lax\";\n                break;\n            case \"strict\":\n                str += \"; SameSite=Strict\";\n                break;\n            case \"none\":\n                str += \"; SameSite=None\";\n                break;\n            default:\n                throw new TypeError(\"option sameSite is invalid\");\n        }\n    }\n    if (opt.partitioned) str += \"; Partitioned\";\n    return str;\n};\nconst cookie = {\n    create (name, value, minutes, domain) {\n        let cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n            path: \"/\",\n            sameSite: \"strict\"\n        };\n        if (minutes) {\n            cookieOptions.expires = new Date();\n            cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1000);\n        }\n        if (domain) cookieOptions.domain = domain;\n        document.cookie = serializeCookie(name, value, cookieOptions);\n    },\n    read (name) {\n        const nameEQ = `${name}=`;\n        const ca = document.cookie.split(\";\");\n        for(let i = 0; i < ca.length; i++){\n            let c = ca[i];\n            while(c.charAt(0) === \" \")c = c.substring(1, c.length);\n            if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\n        }\n        return null;\n    },\n    remove (name, domain) {\n        this.create(name, \"\", -1, domain);\n    }\n};\nvar cookie$1 = {\n    name: \"cookie\",\n    // Deconstruct the options object and extract the lookupCookie property\n    lookup (_ref) {\n        let { lookupCookie } = _ref;\n        if (lookupCookie && typeof document !== \"undefined\") {\n            return cookie.read(lookupCookie) || undefined;\n        }\n        return undefined;\n    },\n    // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties\n    cacheUserLanguage (lng, _ref2) {\n        let { lookupCookie, cookieMinutes, cookieDomain, cookieOptions } = _ref2;\n        if (lookupCookie && typeof document !== \"undefined\") {\n            cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);\n        }\n    }\n};\nvar querystring = {\n    name: \"querystring\",\n    // Deconstruct the options object and extract the lookupQuerystring property\n    lookup (_ref) {\n        let { lookupQuerystring } = _ref;\n        let found;\n        if (false) {}\n        return found;\n    }\n};\nvar hash = {\n    name: \"hash\",\n    // Deconstruct the options object and extract the lookupHash property and the lookupFromHashIndex property\n    lookup (_ref) {\n        let { lookupHash, lookupFromHashIndex } = _ref;\n        let found;\n        if (false) {}\n        return found;\n    }\n};\nlet hasLocalStorageSupport = null;\nconst localStorageAvailable = ()=>{\n    if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;\n    try {\n        hasLocalStorageSupport =  false && 0;\n        if (!hasLocalStorageSupport) {\n            return false;\n        }\n        const testKey = \"i18next.translate.boo\";\n        window.localStorage.setItem(testKey, \"foo\");\n        window.localStorage.removeItem(testKey);\n    } catch (e) {\n        hasLocalStorageSupport = false;\n    }\n    return hasLocalStorageSupport;\n};\nvar localStorage = {\n    name: \"localStorage\",\n    // Deconstruct the options object and extract the lookupLocalStorage property\n    lookup (_ref) {\n        let { lookupLocalStorage } = _ref;\n        if (lookupLocalStorage && localStorageAvailable()) {\n            return window.localStorage.getItem(lookupLocalStorage) || undefined; // Undefined ensures type consistency with the previous version of this function\n        }\n        return undefined;\n    },\n    // Deconstruct the options object and extract the lookupLocalStorage property\n    cacheUserLanguage (lng, _ref2) {\n        let { lookupLocalStorage } = _ref2;\n        if (lookupLocalStorage && localStorageAvailable()) {\n            window.localStorage.setItem(lookupLocalStorage, lng);\n        }\n    }\n};\nlet hasSessionStorageSupport = null;\nconst sessionStorageAvailable = ()=>{\n    if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;\n    try {\n        hasSessionStorageSupport =  false && 0;\n        if (!hasSessionStorageSupport) {\n            return false;\n        }\n        const testKey = \"i18next.translate.boo\";\n        window.sessionStorage.setItem(testKey, \"foo\");\n        window.sessionStorage.removeItem(testKey);\n    } catch (e) {\n        hasSessionStorageSupport = false;\n    }\n    return hasSessionStorageSupport;\n};\nvar sessionStorage = {\n    name: \"sessionStorage\",\n    lookup (_ref) {\n        let { lookupSessionStorage } = _ref;\n        if (lookupSessionStorage && sessionStorageAvailable()) {\n            return window.sessionStorage.getItem(lookupSessionStorage) || undefined;\n        }\n        return undefined;\n    },\n    cacheUserLanguage (lng, _ref2) {\n        let { lookupSessionStorage } = _ref2;\n        if (lookupSessionStorage && sessionStorageAvailable()) {\n            window.sessionStorage.setItem(lookupSessionStorage, lng);\n        }\n    }\n};\nvar navigator$1 = {\n    name: \"navigator\",\n    lookup (options) {\n        const found = [];\n        if (typeof navigator !== \"undefined\") {\n            const { languages, userLanguage, language } = navigator;\n            if (languages) {\n                // chrome only; not an array, so can't use .push.apply instead of iterating\n                for(let i = 0; i < languages.length; i++){\n                    found.push(languages[i]);\n                }\n            }\n            if (userLanguage) {\n                found.push(userLanguage);\n            }\n            if (language) {\n                found.push(language);\n            }\n        }\n        return found.length > 0 ? found : undefined;\n    }\n};\nvar htmlTag = {\n    name: \"htmlTag\",\n    // Deconstruct the options object and extract the htmlTag property\n    lookup (_ref) {\n        let { htmlTag } = _ref;\n        let found;\n        const internalHtmlTag = htmlTag || (typeof document !== \"undefined\" ? document.documentElement : null);\n        if (internalHtmlTag && typeof internalHtmlTag.getAttribute === \"function\") {\n            found = internalHtmlTag.getAttribute(\"lang\");\n        }\n        return found;\n    }\n};\nvar path = {\n    name: \"path\",\n    // Deconstruct the options object and extract the lookupFromPathIndex property\n    lookup (_ref) {\n        let { lookupFromPathIndex } = _ref;\n        if (true) return undefined;\n        const language = window.location.pathname.match(/\\/([a-zA-Z-]*)/g);\n        if (!Array.isArray(language)) return undefined;\n        const index = typeof lookupFromPathIndex === \"number\" ? lookupFromPathIndex : 0;\n        return language[index]?.replace(\"/\", \"\");\n    }\n};\nvar subdomain = {\n    name: \"subdomain\",\n    lookup (_ref) {\n        let { lookupFromSubdomainIndex } = _ref;\n        // If given get the subdomain index else 1\n        const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === \"number\" ? lookupFromSubdomainIndex + 1 : 1;\n        // get all matches if window.location. is existing\n        // first item of match is the match itself and the second is the first group match which should be the first subdomain match\n        // is the hostname no public domain get the or option of localhost\n        const language =  false && 0;\n        // if there is no match (null) return undefined\n        if (!language) return undefined;\n        // return the given group match\n        return language[internalLookupFromSubdomainIndex];\n    }\n};\n// some environments, throws when accessing document.cookie\nlet canCookies = false;\ntry {\n    // eslint-disable-next-line no-unused-expressions\n    document.cookie;\n    canCookies = true;\n// eslint-disable-next-line no-empty\n} catch (e) {}\nconst order = [\n    \"querystring\",\n    \"cookie\",\n    \"localStorage\",\n    \"sessionStorage\",\n    \"navigator\",\n    \"htmlTag\"\n];\nif (!canCookies) order.splice(1, 1);\nconst getDefaults = ()=>({\n        order,\n        lookupQuerystring: \"lng\",\n        lookupCookie: \"i18next\",\n        lookupLocalStorage: \"i18nextLng\",\n        lookupSessionStorage: \"i18nextLng\",\n        // cache user language\n        caches: [\n            \"localStorage\"\n        ],\n        excludeCacheFor: [\n            \"cimode\"\n        ],\n        // cookieMinutes: 10,\n        // cookieDomain: 'myDomain'\n        convertDetectedLanguage: (l)=>l\n    });\nclass Browser {\n    constructor(services){\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.type = \"languageDetector\";\n        this.detectors = {};\n        this.init(services, options);\n    }\n    init() {\n        let services = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n            languageUtils: {}\n        };\n        let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this.services = services;\n        this.options = defaults(options, this.options || {}, getDefaults());\n        if (typeof this.options.convertDetectedLanguage === \"string\" && this.options.convertDetectedLanguage.indexOf(\"15897\") > -1) {\n            this.options.convertDetectedLanguage = (l)=>l.replace(\"-\", \"_\");\n        }\n        // backwards compatibility\n        if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;\n        this.i18nOptions = i18nOptions;\n        this.addDetector(cookie$1);\n        this.addDetector(querystring);\n        this.addDetector(localStorage);\n        this.addDetector(sessionStorage);\n        this.addDetector(navigator$1);\n        this.addDetector(htmlTag);\n        this.addDetector(path);\n        this.addDetector(subdomain);\n        this.addDetector(hash);\n    }\n    addDetector(detector) {\n        this.detectors[detector.name] = detector;\n        return this;\n    }\n    detect() {\n        let detectionOrder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.order;\n        let detected = [];\n        detectionOrder.forEach((detectorName)=>{\n            if (this.detectors[detectorName]) {\n                let lookup = this.detectors[detectorName].lookup(this.options);\n                if (lookup && typeof lookup === \"string\") lookup = [\n                    lookup\n                ];\n                if (lookup) detected = detected.concat(lookup);\n            }\n        });\n        detected = detected.filter((d)=>d !== undefined && d !== null && !hasXSS(d)).map((d)=>this.options.convertDetectedLanguage(d));\n        if (this.services && this.services.languageUtils && this.services.languageUtils.getBestMatchFromCodes) return detected; // new i18next v19.5.0\n        return detected.length > 0 ? detected[0] : null; // a little backward compatibility\n    }\n    cacheUserLanguage(lng) {\n        let caches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.caches;\n        if (!caches) return;\n        if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;\n        caches.forEach((cacheName)=>{\n            if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);\n        });\n    }\n}\nBrowser.type = \"languageDetector\";\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2kxOG5leHQtYnJvd3Nlci1sYW5ndWFnZWRldGVjdG9yL2Rpc3QvZXNtL2kxOG5leHRCcm93c2VyTGFuZ3VhZ2VEZXRlY3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTSxFQUNKQSxLQUFLLEVBQ0xDLE9BQU8sRUFDUixHQUFHLEVBQUU7QUFDTixTQUFTQyxTQUFTQyxHQUFHO0lBQ25CRixRQUFRRyxJQUFJLENBQUNKLE1BQU1JLElBQUksQ0FBQ0MsV0FBVyxJQUFJQyxDQUFBQTtRQUNyQyxJQUFJQSxRQUFRO1lBQ1YsSUFBSyxNQUFNQyxRQUFRRCxPQUFRO2dCQUN6QixJQUFJSCxHQUFHLENBQUNJLEtBQUssS0FBS0MsV0FBV0wsR0FBRyxDQUFDSSxLQUFLLEdBQUdELE1BQU0sQ0FBQ0MsS0FBSztZQUN2RDtRQUNGO0lBQ0Y7SUFDQSxPQUFPSjtBQUNUO0FBQ0EsU0FBU00sT0FBT0MsS0FBSztJQUNuQixJQUFJLE9BQU9BLFVBQVUsVUFBVSxPQUFPO0lBRXRDLDZCQUE2QjtJQUM3QixNQUFNQyxjQUFjO1FBQUM7UUFBbUI7UUFBd0I7UUFBd0I7UUFBNEI7UUFBbUI7UUFBaUI7UUFBb0I7UUFBYztRQUFlO1FBQXFCO1FBQXlCO1FBQXFCO0tBQWE7SUFDelIsT0FBT0EsWUFBWUMsSUFBSSxDQUFDQyxDQUFBQSxVQUFXQSxRQUFRQyxJQUFJLENBQUNKO0FBQ2xEO0FBRUEsNENBQTRDO0FBQzVDLE1BQU1LLHFCQUFxQjtBQUMzQixNQUFNQyxrQkFBa0IsU0FBVUMsSUFBSSxFQUFFQyxHQUFHO0lBQ3pDLElBQUlDLFVBQVVkLFVBQVVlLE1BQU0sR0FBRyxLQUFLZixTQUFTLENBQUMsRUFBRSxLQUFLRyxZQUFZSCxTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ2hGZ0IsTUFBTTtJQUNSO0lBQ0EsTUFBTUMsTUFBTUg7SUFDWixNQUFNSSxRQUFRQyxtQkFBbUJOO0lBQ2pDLElBQUlPLE1BQU0sQ0FBQyxFQUFFUixLQUFLLENBQUMsRUFBRU0sTUFBTSxDQUFDO0lBQzVCLElBQUlELElBQUlJLE1BQU0sR0FBRyxHQUFHO1FBQ2xCLE1BQU1BLFNBQVNKLElBQUlJLE1BQU0sR0FBRztRQUM1QixJQUFJQyxPQUFPQyxLQUFLLENBQUNGLFNBQVMsTUFBTSxJQUFJRyxNQUFNO1FBQzFDSixPQUFPLENBQUMsVUFBVSxFQUFFSyxLQUFLQyxLQUFLLENBQUNMLFFBQVEsQ0FBQztJQUMxQztJQUNBLElBQUlKLElBQUlVLE1BQU0sRUFBRTtRQUNkLElBQUksQ0FBQ2pCLG1CQUFtQkQsSUFBSSxDQUFDUSxJQUFJVSxNQUFNLEdBQUc7WUFDeEMsTUFBTSxJQUFJQyxVQUFVO1FBQ3RCO1FBQ0FSLE9BQU8sQ0FBQyxTQUFTLEVBQUVILElBQUlVLE1BQU0sQ0FBQyxDQUFDO0lBQ2pDO0lBQ0EsSUFBSVYsSUFBSUQsSUFBSSxFQUFFO1FBQ1osSUFBSSxDQUFDTixtQkFBbUJELElBQUksQ0FBQ1EsSUFBSUQsSUFBSSxHQUFHO1lBQ3RDLE1BQU0sSUFBSVksVUFBVTtRQUN0QjtRQUNBUixPQUFPLENBQUMsT0FBTyxFQUFFSCxJQUFJRCxJQUFJLENBQUMsQ0FBQztJQUM3QjtJQUNBLElBQUlDLElBQUlZLE9BQU8sRUFBRTtRQUNmLElBQUksT0FBT1osSUFBSVksT0FBTyxDQUFDQyxXQUFXLEtBQUssWUFBWTtZQUNqRCxNQUFNLElBQUlGLFVBQVU7UUFDdEI7UUFDQVIsT0FBTyxDQUFDLFVBQVUsRUFBRUgsSUFBSVksT0FBTyxDQUFDQyxXQUFXLEdBQUcsQ0FBQztJQUNqRDtJQUNBLElBQUliLElBQUljLFFBQVEsRUFBRVgsT0FBTztJQUN6QixJQUFJSCxJQUFJZSxNQUFNLEVBQUVaLE9BQU87SUFDdkIsSUFBSUgsSUFBSWdCLFFBQVEsRUFBRTtRQUNoQixNQUFNQSxXQUFXLE9BQU9oQixJQUFJZ0IsUUFBUSxLQUFLLFdBQVdoQixJQUFJZ0IsUUFBUSxDQUFDQyxXQUFXLEtBQUtqQixJQUFJZ0IsUUFBUTtRQUM3RixPQUFRQTtZQUNOLEtBQUs7Z0JBQ0hiLE9BQU87Z0JBQ1A7WUFDRixLQUFLO2dCQUNIQSxPQUFPO2dCQUNQO1lBQ0YsS0FBSztnQkFDSEEsT0FBTztnQkFDUDtZQUNGLEtBQUs7Z0JBQ0hBLE9BQU87Z0JBQ1A7WUFDRjtnQkFDRSxNQUFNLElBQUlRLFVBQVU7UUFDeEI7SUFDRjtJQUNBLElBQUlYLElBQUlrQixXQUFXLEVBQUVmLE9BQU87SUFDNUIsT0FBT0E7QUFDVDtBQUNBLE1BQU1nQixTQUFTO0lBQ2JDLFFBQU96QixJQUFJLEVBQUVNLEtBQUssRUFBRW9CLE9BQU8sRUFBRVgsTUFBTTtRQUNqQyxJQUFJWSxnQkFBZ0J2QyxVQUFVZSxNQUFNLEdBQUcsS0FBS2YsU0FBUyxDQUFDLEVBQUUsS0FBS0csWUFBWUgsU0FBUyxDQUFDLEVBQUUsR0FBRztZQUN0RmdCLE1BQU07WUFDTmlCLFVBQVU7UUFDWjtRQUNBLElBQUlLLFNBQVM7WUFDWEMsY0FBY1YsT0FBTyxHQUFHLElBQUlXO1lBQzVCRCxjQUFjVixPQUFPLENBQUNZLE9BQU8sQ0FBQ0YsY0FBY1YsT0FBTyxDQUFDYSxPQUFPLEtBQUtKLFVBQVUsS0FBSztRQUNqRjtRQUNBLElBQUlYLFFBQVFZLGNBQWNaLE1BQU0sR0FBR0E7UUFDbkNnQixTQUFTUCxNQUFNLEdBQUd6QixnQkFBZ0JDLE1BQU1NLE9BQU9xQjtJQUNqRDtJQUNBSyxNQUFLaEMsSUFBSTtRQUNQLE1BQU1pQyxTQUFTLENBQUMsRUFBRWpDLEtBQUssQ0FBQyxDQUFDO1FBQ3pCLE1BQU1rQyxLQUFLSCxTQUFTUCxNQUFNLENBQUNXLEtBQUssQ0FBQztRQUNqQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsR0FBRy9CLE1BQU0sRUFBRWlDLElBQUs7WUFDbEMsSUFBSUMsSUFBSUgsRUFBRSxDQUFDRSxFQUFFO1lBQ2IsTUFBT0MsRUFBRUMsTUFBTSxDQUFDLE9BQU8sSUFBS0QsSUFBSUEsRUFBRUUsU0FBUyxDQUFDLEdBQUdGLEVBQUVsQyxNQUFNO1lBQ3ZELElBQUlrQyxFQUFFRyxPQUFPLENBQUNQLFlBQVksR0FBRyxPQUFPSSxFQUFFRSxTQUFTLENBQUNOLE9BQU85QixNQUFNLEVBQUVrQyxFQUFFbEMsTUFBTTtRQUN6RTtRQUNBLE9BQU87SUFDVDtJQUNBc0MsUUFBT3pDLElBQUksRUFBRWUsTUFBTTtRQUNqQixJQUFJLENBQUNVLE1BQU0sQ0FBQ3pCLE1BQU0sSUFBSSxDQUFDLEdBQUdlO0lBQzVCO0FBQ0Y7QUFDQSxJQUFJMkIsV0FBVztJQUNiMUMsTUFBTTtJQUNOLHVFQUF1RTtJQUN2RTJDLFFBQU9DLElBQUk7UUFDVCxJQUFJLEVBQ0ZDLFlBQVksRUFDYixHQUFHRDtRQUNKLElBQUlDLGdCQUFnQixPQUFPZCxhQUFhLGFBQWE7WUFDbkQsT0FBT1AsT0FBT1EsSUFBSSxDQUFDYSxpQkFBaUJ0RDtRQUN0QztRQUNBLE9BQU9BO0lBQ1Q7SUFDQSx5SEFBeUg7SUFDekh1RCxtQkFBa0JDLEdBQUcsRUFBRUMsS0FBSztRQUMxQixJQUFJLEVBQ0ZILFlBQVksRUFDWkksYUFBYSxFQUNiQyxZQUFZLEVBQ1p2QixhQUFhLEVBQ2QsR0FBR3FCO1FBQ0osSUFBSUgsZ0JBQWdCLE9BQU9kLGFBQWEsYUFBYTtZQUNuRFAsT0FBT0MsTUFBTSxDQUFDb0IsY0FBY0UsS0FBS0UsZUFBZUMsY0FBY3ZCO1FBQ2hFO0lBQ0Y7QUFDRjtBQUVBLElBQUl3QixjQUFjO0lBQ2hCbkQsTUFBTTtJQUNOLDRFQUE0RTtJQUM1RTJDLFFBQU9DLElBQUk7UUFDVCxJQUFJLEVBQ0ZRLGlCQUFpQixFQUNsQixHQUFHUjtRQUNKLElBQUlTO1FBQ0osSUFBSSxLQUFrQixFQUFhLEVBa0JsQztRQUNELE9BQU9BO0lBQ1Q7QUFDRjtBQUVBLElBQUlJLE9BQU87SUFDVHpELE1BQU07SUFDTiwwR0FBMEc7SUFDMUcyQyxRQUFPQyxJQUFJO1FBQ1QsSUFBSSxFQUNGa0IsVUFBVSxFQUNWQyxtQkFBbUIsRUFDcEIsR0FBR25CO1FBQ0osSUFBSVM7UUFDSixJQUFJLEtBQWtCLEVBQWEsRUEwQmxDO1FBQ0QsT0FBT0E7SUFDVDtBQUNGO0FBRUEsSUFBSWlCLHlCQUF5QjtBQUM3QixNQUFNQyx3QkFBd0I7SUFDNUIsSUFBSUQsMkJBQTJCLE1BQU0sT0FBT0E7SUFDNUMsSUFBSTtRQUNGQSx5QkFBeUIsTUFBa0IsSUFBZWYsQ0FBNEI7UUFDdEYsSUFBSSxDQUFDZSx3QkFBd0I7WUFDM0IsT0FBTztRQUNUO1FBQ0EsTUFBTUcsVUFBVTtRQUNoQmxCLE9BQU9pQixZQUFZLENBQUNFLE9BQU8sQ0FBQ0QsU0FBUztRQUNyQ2xCLE9BQU9pQixZQUFZLENBQUNHLFVBQVUsQ0FBQ0Y7SUFDakMsRUFBRSxPQUFPRyxHQUFHO1FBQ1ZOLHlCQUF5QjtJQUMzQjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJRSxlQUFlO0lBQ2pCeEUsTUFBTTtJQUNOLDZFQUE2RTtJQUM3RTJDLFFBQU9DLElBQUk7UUFDVCxJQUFJLEVBQ0ZpQyxrQkFBa0IsRUFDbkIsR0FBR2pDO1FBQ0osSUFBSWlDLHNCQUFzQk4seUJBQXlCO1lBQ2pELE9BQU9oQixPQUFPaUIsWUFBWSxDQUFDTSxPQUFPLENBQUNELHVCQUF1QnRGLFdBQVcsZ0ZBQWdGO1FBQ3ZKO1FBQ0EsT0FBT0E7SUFDVDtJQUNBLDZFQUE2RTtJQUM3RXVELG1CQUFrQkMsR0FBRyxFQUFFQyxLQUFLO1FBQzFCLElBQUksRUFDRjZCLGtCQUFrQixFQUNuQixHQUFHN0I7UUFDSixJQUFJNkIsc0JBQXNCTix5QkFBeUI7WUFDakRoQixPQUFPaUIsWUFBWSxDQUFDRSxPQUFPLENBQUNHLG9CQUFvQjlCO1FBQ2xEO0lBQ0Y7QUFDRjtBQUVBLElBQUlnQywyQkFBMkI7QUFDL0IsTUFBTUMsMEJBQTBCO0lBQzlCLElBQUlELDZCQUE2QixNQUFNLE9BQU9BO0lBQzlDLElBQUk7UUFDRkEsMkJBQTJCLE1BQWtCLElBQWV4QixDQUE4QjtRQUMxRixJQUFJLENBQUN3QiwwQkFBMEI7WUFDN0IsT0FBTztRQUNUO1FBQ0EsTUFBTU4sVUFBVTtRQUNoQmxCLE9BQU8wQixjQUFjLENBQUNQLE9BQU8sQ0FBQ0QsU0FBUztRQUN2Q2xCLE9BQU8wQixjQUFjLENBQUNOLFVBQVUsQ0FBQ0Y7SUFDbkMsRUFBRSxPQUFPRyxHQUFHO1FBQ1ZHLDJCQUEyQjtJQUM3QjtJQUNBLE9BQU9BO0FBQ1Q7QUFDQSxJQUFJRSxpQkFBaUI7SUFDbkJqRixNQUFNO0lBQ04yQyxRQUFPQyxJQUFJO1FBQ1QsSUFBSSxFQUNGc0Msb0JBQW9CLEVBQ3JCLEdBQUd0QztRQUNKLElBQUlzQyx3QkFBd0JGLDJCQUEyQjtZQUNyRCxPQUFPekIsT0FBTzBCLGNBQWMsQ0FBQ0gsT0FBTyxDQUFDSSx5QkFBeUIzRjtRQUNoRTtRQUNBLE9BQU9BO0lBQ1Q7SUFDQXVELG1CQUFrQkMsR0FBRyxFQUFFQyxLQUFLO1FBQzFCLElBQUksRUFDRmtDLG9CQUFvQixFQUNyQixHQUFHbEM7UUFDSixJQUFJa0Msd0JBQXdCRiwyQkFBMkI7WUFDckR6QixPQUFPMEIsY0FBYyxDQUFDUCxPQUFPLENBQUNRLHNCQUFzQm5DO1FBQ3REO0lBQ0Y7QUFDRjtBQUVBLElBQUlvQyxjQUFjO0lBQ2hCbkYsTUFBTTtJQUNOMkMsUUFBT3pDLE9BQU87UUFDWixNQUFNbUQsUUFBUSxFQUFFO1FBQ2hCLElBQUksT0FBTytCLGNBQWMsYUFBYTtZQUNwQyxNQUFNLEVBQ0pDLFNBQVMsRUFDVEMsWUFBWSxFQUNadEIsUUFBUSxFQUNULEdBQUdvQjtZQUNKLElBQUlDLFdBQVc7Z0JBQ2IsMkVBQTJFO2dCQUMzRSxJQUFLLElBQUlqRCxJQUFJLEdBQUdBLElBQUlpRCxVQUFVbEYsTUFBTSxFQUFFaUMsSUFBSztvQkFDekNpQixNQUFNa0MsSUFBSSxDQUFDRixTQUFTLENBQUNqRCxFQUFFO2dCQUN6QjtZQUNGO1lBQ0EsSUFBSWtELGNBQWM7Z0JBQ2hCakMsTUFBTWtDLElBQUksQ0FBQ0Q7WUFDYjtZQUNBLElBQUl0QixVQUFVO2dCQUNaWCxNQUFNa0MsSUFBSSxDQUFDdkI7WUFDYjtRQUNGO1FBQ0EsT0FBT1gsTUFBTWxELE1BQU0sR0FBRyxJQUFJa0QsUUFBUTlEO0lBQ3BDO0FBQ0Y7QUFFQSxJQUFJaUcsVUFBVTtJQUNaeEYsTUFBTTtJQUNOLGtFQUFrRTtJQUNsRTJDLFFBQU9DLElBQUk7UUFDVCxJQUFJLEVBQ0Y0QyxPQUFPLEVBQ1IsR0FBRzVDO1FBQ0osSUFBSVM7UUFDSixNQUFNb0Msa0JBQWtCRCxXQUFZLFFBQU96RCxhQUFhLGNBQWNBLFNBQVMyRCxlQUFlLEdBQUcsSUFBRztRQUNwRyxJQUFJRCxtQkFBbUIsT0FBT0EsZ0JBQWdCRSxZQUFZLEtBQUssWUFBWTtZQUN6RXRDLFFBQVFvQyxnQkFBZ0JFLFlBQVksQ0FBQztRQUN2QztRQUNBLE9BQU90QztJQUNUO0FBQ0Y7QUFFQSxJQUFJakQsT0FBTztJQUNUSixNQUFNO0lBQ04sOEVBQThFO0lBQzlFMkMsUUFBT0MsSUFBSTtRQUNULElBQUksRUFDRmdELG1CQUFtQixFQUNwQixHQUFHaEQ7UUFDSixJQUFJLElBQWtCLEVBQWEsT0FBT3JEO1FBQzFDLE1BQU15RSxXQUFXVCxPQUFPQyxRQUFRLENBQUNxQyxRQUFRLENBQUM1QixLQUFLLENBQUM7UUFDaEQsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNILFdBQVcsT0FBT3pFO1FBQ3JDLE1BQU02RSxRQUFRLE9BQU93Qix3QkFBd0IsV0FBV0Esc0JBQXNCO1FBQzlFLE9BQU81QixRQUFRLENBQUNJLE1BQU0sRUFBRUMsUUFBUSxLQUFLO0lBQ3ZDO0FBQ0Y7QUFFQSxJQUFJeUIsWUFBWTtJQUNkOUYsTUFBTTtJQUNOMkMsUUFBT0MsSUFBSTtRQUNULElBQUksRUFDRm1ELHdCQUF3QixFQUN6QixHQUFHbkQ7UUFDSiwwQ0FBMEM7UUFDMUMsTUFBTW9ELG1DQUFtQyxPQUFPRCw2QkFBNkIsV0FBV0EsMkJBQTJCLElBQUk7UUFDdkgsa0RBQWtEO1FBQ2xELDRIQUE0SDtRQUM1SCxrRUFBa0U7UUFDbEUsTUFBTS9CLFdBQVcsTUFBa0IsSUFBZVQsQ0FBMEY7UUFFNUksK0NBQStDO1FBQy9DLElBQUksQ0FBQ1MsVUFBVSxPQUFPekU7UUFDdEIsK0JBQStCO1FBQy9CLE9BQU95RSxRQUFRLENBQUNnQyxpQ0FBaUM7SUFDbkQ7QUFDRjtBQUVBLDJEQUEyRDtBQUMzRCxJQUFJRSxhQUFhO0FBQ2pCLElBQUk7SUFDRixpREFBaUQ7SUFDakRuRSxTQUFTUCxNQUFNO0lBQ2YwRSxhQUFhO0FBQ2Isb0NBQW9DO0FBQ3RDLEVBQUUsT0FBT3RCLEdBQUcsQ0FBQztBQUNiLE1BQU11QixRQUFRO0lBQUM7SUFBZTtJQUFVO0lBQWdCO0lBQWtCO0lBQWE7Q0FBVTtBQUNqRyxJQUFJLENBQUNELFlBQVlDLE1BQU1DLE1BQU0sQ0FBQyxHQUFHO0FBQ2pDLE1BQU1DLGNBQWMsSUFBTztRQUN6QkY7UUFDQS9DLG1CQUFtQjtRQUNuQlAsY0FBYztRQUNkZ0Msb0JBQW9CO1FBQ3BCSyxzQkFBc0I7UUFDdEIsc0JBQXNCO1FBQ3RCb0IsUUFBUTtZQUFDO1NBQWU7UUFDeEJDLGlCQUFpQjtZQUFDO1NBQVM7UUFDM0IscUJBQXFCO1FBQ3JCLDJCQUEyQjtRQUUzQkMseUJBQXlCQyxDQUFBQSxJQUFLQTtJQUNoQztBQUNBLE1BQU1DO0lBQ0pDLFlBQVlDLFFBQVEsQ0FBRTtRQUNwQixJQUFJMUcsVUFBVWQsVUFBVWUsTUFBTSxHQUFHLEtBQUtmLFNBQVMsQ0FBQyxFQUFFLEtBQUtHLFlBQVlILFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJLENBQUN5SCxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFNBQVMsR0FBRyxDQUFDO1FBQ2xCLElBQUksQ0FBQ0MsSUFBSSxDQUFDSCxVQUFVMUc7SUFDdEI7SUFDQTZHLE9BQU87UUFDTCxJQUFJSCxXQUFXeEgsVUFBVWUsTUFBTSxHQUFHLEtBQUtmLFNBQVMsQ0FBQyxFQUFFLEtBQUtHLFlBQVlILFNBQVMsQ0FBQyxFQUFFLEdBQUc7WUFDakY0SCxlQUFlLENBQUM7UUFDbEI7UUFDQSxJQUFJOUcsVUFBVWQsVUFBVWUsTUFBTSxHQUFHLEtBQUtmLFNBQVMsQ0FBQyxFQUFFLEtBQUtHLFlBQVlILFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixJQUFJNkgsY0FBYzdILFVBQVVlLE1BQU0sR0FBRyxLQUFLZixTQUFTLENBQUMsRUFBRSxLQUFLRyxZQUFZSCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDdkYsSUFBSSxDQUFDd0gsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUMxRyxPQUFPLEdBQUdqQixTQUFTaUIsU0FBUyxJQUFJLENBQUNBLE9BQU8sSUFBSSxDQUFDLEdBQUdtRztRQUNyRCxJQUFJLE9BQU8sSUFBSSxDQUFDbkcsT0FBTyxDQUFDc0csdUJBQXVCLEtBQUssWUFBWSxJQUFJLENBQUN0RyxPQUFPLENBQUNzRyx1QkFBdUIsQ0FBQ2hFLE9BQU8sQ0FBQyxXQUFXLENBQUMsR0FBRztZQUMxSCxJQUFJLENBQUN0QyxPQUFPLENBQUNzRyx1QkFBdUIsR0FBR0MsQ0FBQUEsSUFBS0EsRUFBRXBDLE9BQU8sQ0FBQyxLQUFLO1FBQzdEO1FBRUEsMEJBQTBCO1FBQzFCLElBQUksSUFBSSxDQUFDbkUsT0FBTyxDQUFDZ0gsa0JBQWtCLEVBQUUsSUFBSSxDQUFDaEgsT0FBTyxDQUFDMEYsbUJBQW1CLEdBQUcsSUFBSSxDQUFDMUYsT0FBTyxDQUFDZ0gsa0JBQWtCO1FBQ3ZHLElBQUksQ0FBQ0QsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUNFLFdBQVcsQ0FBQ3pFO1FBQ2pCLElBQUksQ0FBQ3lFLFdBQVcsQ0FBQ2hFO1FBQ2pCLElBQUksQ0FBQ2dFLFdBQVcsQ0FBQzNDO1FBQ2pCLElBQUksQ0FBQzJDLFdBQVcsQ0FBQ2xDO1FBQ2pCLElBQUksQ0FBQ2tDLFdBQVcsQ0FBQ2hDO1FBQ2pCLElBQUksQ0FBQ2dDLFdBQVcsQ0FBQzNCO1FBQ2pCLElBQUksQ0FBQzJCLFdBQVcsQ0FBQy9HO1FBQ2pCLElBQUksQ0FBQytHLFdBQVcsQ0FBQ3JCO1FBQ2pCLElBQUksQ0FBQ3FCLFdBQVcsQ0FBQzFEO0lBQ25CO0lBQ0EwRCxZQUFZQyxRQUFRLEVBQUU7UUFDcEIsSUFBSSxDQUFDTixTQUFTLENBQUNNLFNBQVNwSCxJQUFJLENBQUMsR0FBR29IO1FBQ2hDLE9BQU8sSUFBSTtJQUNiO0lBQ0FDLFNBQVM7UUFDUCxJQUFJQyxpQkFBaUJsSSxVQUFVZSxNQUFNLEdBQUcsS0FBS2YsU0FBUyxDQUFDLEVBQUUsS0FBS0csWUFBWUgsU0FBUyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNjLE9BQU8sQ0FBQ2lHLEtBQUs7UUFDM0csSUFBSW9CLFdBQVcsRUFBRTtRQUNqQkQsZUFBZXRJLE9BQU8sQ0FBQ3dJLENBQUFBO1lBQ3JCLElBQUksSUFBSSxDQUFDVixTQUFTLENBQUNVLGFBQWEsRUFBRTtnQkFDaEMsSUFBSTdFLFNBQVMsSUFBSSxDQUFDbUUsU0FBUyxDQUFDVSxhQUFhLENBQUM3RSxNQUFNLENBQUMsSUFBSSxDQUFDekMsT0FBTztnQkFDN0QsSUFBSXlDLFVBQVUsT0FBT0EsV0FBVyxVQUFVQSxTQUFTO29CQUFDQTtpQkFBTztnQkFDM0QsSUFBSUEsUUFBUTRFLFdBQVdBLFNBQVNFLE1BQU0sQ0FBQzlFO1lBQ3pDO1FBQ0Y7UUFDQTRFLFdBQVdBLFNBQVNHLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBS0EsTUFBTXBJLGFBQWFvSSxNQUFNLFFBQVEsQ0FBQ25JLE9BQU9tSSxJQUFJQyxHQUFHLENBQUNELENBQUFBLElBQUssSUFBSSxDQUFDekgsT0FBTyxDQUFDc0csdUJBQXVCLENBQUNtQjtRQUMzSCxJQUFJLElBQUksQ0FBQ2YsUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxDQUFDSSxhQUFhLElBQUksSUFBSSxDQUFDSixRQUFRLENBQUNJLGFBQWEsQ0FBQ2EscUJBQXFCLEVBQUUsT0FBT04sVUFBVSxzQkFBc0I7UUFDOUksT0FBT0EsU0FBU3BILE1BQU0sR0FBRyxJQUFJb0gsUUFBUSxDQUFDLEVBQUUsR0FBRyxNQUFNLGtDQUFrQztJQUNyRjtJQUNBekUsa0JBQWtCQyxHQUFHLEVBQUU7UUFDckIsSUFBSXVELFNBQVNsSCxVQUFVZSxNQUFNLEdBQUcsS0FBS2YsU0FBUyxDQUFDLEVBQUUsS0FBS0csWUFBWUgsU0FBUyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUNjLE9BQU8sQ0FBQ29HLE1BQU07UUFDcEcsSUFBSSxDQUFDQSxRQUFRO1FBQ2IsSUFBSSxJQUFJLENBQUNwRyxPQUFPLENBQUNxRyxlQUFlLElBQUksSUFBSSxDQUFDckcsT0FBTyxDQUFDcUcsZUFBZSxDQUFDL0QsT0FBTyxDQUFDTyxPQUFPLENBQUMsR0FBRztRQUNwRnVELE9BQU90SCxPQUFPLENBQUM4SSxDQUFBQTtZQUNiLElBQUksSUFBSSxDQUFDaEIsU0FBUyxDQUFDZ0IsVUFBVSxFQUFFLElBQUksQ0FBQ2hCLFNBQVMsQ0FBQ2dCLFVBQVUsQ0FBQ2hGLGlCQUFpQixDQUFDQyxLQUFLLElBQUksQ0FBQzdDLE9BQU87UUFDOUY7SUFDRjtBQUNGO0FBQ0F3RyxRQUFRRyxJQUFJLEdBQUc7QUFFZSIsInNvdXJjZXMiOlsid2VicGFjazovL2F3cy1jb3N0LWd1YXJkaWFuLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9pMThuZXh0LWJyb3dzZXItbGFuZ3VhZ2VkZXRlY3Rvci9kaXN0L2VzbS9pMThuZXh0QnJvd3Nlckxhbmd1YWdlRGV0ZWN0b3IuanM/MzM5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7XG4gIHNsaWNlLFxuICBmb3JFYWNoXG59ID0gW107XG5mdW5jdGlvbiBkZWZhdWx0cyhvYmopIHtcbiAgZm9yRWFjaC5jYWxsKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgc291cmNlID0+IHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0gPT09IHVuZGVmaW5lZCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBoYXNYU1MoaW5wdXQpIHtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21tb24gWFNTIGF0dGFjayBwYXR0ZXJuc1xuICBjb25zdCB4c3NQYXR0ZXJucyA9IFsvPFxccypzY3JpcHQuKj8+L2ksIC88XFxzKlxcL1xccypzY3JpcHRcXHMqPi9pLCAvPFxccyppbWcuKj9vblxcdytcXHMqPS9pLCAvPFxccypcXHcrXFxzKm9uXFx3K1xccyo9Lio/Pi9pLCAvamF2YXNjcmlwdFxccyo6L2ksIC92YnNjcmlwdFxccyo6L2ksIC9leHByZXNzaW9uXFxzKlxcKC9pLCAvZXZhbFxccypcXCgvaSwgL2FsZXJ0XFxzKlxcKC9pLCAvZG9jdW1lbnRcXC5jb29raWUvaSwgL2RvY3VtZW50XFwud3JpdGVcXHMqXFwoL2ksIC93aW5kb3dcXC5sb2NhdGlvbi9pLCAvaW5uZXJIVE1ML2ldO1xuICByZXR1cm4geHNzUGF0dGVybnMuc29tZShwYXR0ZXJuID0+IHBhdHRlcm4udGVzdChpbnB1dCkpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuY29uc3QgZmllbGRDb250ZW50UmVnRXhwID0gL15bXFx1MDAwOVxcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1MDBmZl0rJC87XG5jb25zdCBzZXJpYWxpemVDb29raWUgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7XG4gICAgcGF0aDogJy8nXG4gIH07XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnM7XG4gIGNvbnN0IHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCk7XG4gIGxldCBzdHIgPSBgJHtuYW1lfT0ke3ZhbHVlfWA7XG4gIGlmIChvcHQubWF4QWdlID4gMCkge1xuICAgIGNvbnN0IG1heEFnZSA9IG9wdC5tYXhBZ2UgLSAwO1xuICAgIGlmIChOdW1iZXIuaXNOYU4obWF4QWdlKSkgdGhyb3cgbmV3IEVycm9yKCdtYXhBZ2Ugc2hvdWxkIGJlIGEgTnVtYmVyJyk7XG4gICAgc3RyICs9IGA7IE1heC1BZ2U9JHtNYXRoLmZsb29yKG1heEFnZSl9YDtcbiAgfVxuICBpZiAob3B0LmRvbWFpbikge1xuICAgIGlmICghZmllbGRDb250ZW50UmVnRXhwLnRlc3Qob3B0LmRvbWFpbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBkb21haW4gaXMgaW52YWxpZCcpO1xuICAgIH1cbiAgICBzdHIgKz0gYDsgRG9tYWluPSR7b3B0LmRvbWFpbn1gO1xuICB9XG4gIGlmIChvcHQucGF0aCkge1xuICAgIGlmICghZmllbGRDb250ZW50UmVnRXhwLnRlc3Qob3B0LnBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gcGF0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHN0ciArPSBgOyBQYXRoPSR7b3B0LnBhdGh9YDtcbiAgfVxuICBpZiAob3B0LmV4cGlyZXMpIHtcbiAgICBpZiAodHlwZW9mIG9wdC5leHBpcmVzLnRvVVRDU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gZXhwaXJlcyBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICAgIHN0ciArPSBgOyBFeHBpcmVzPSR7b3B0LmV4cGlyZXMudG9VVENTdHJpbmcoKX1gO1xuICB9XG4gIGlmIChvcHQuaHR0cE9ubHkpIHN0ciArPSAnOyBIdHRwT25seSc7XG4gIGlmIChvcHQuc2VjdXJlKSBzdHIgKz0gJzsgU2VjdXJlJztcbiAgaWYgKG9wdC5zYW1lU2l0ZSkge1xuICAgIGNvbnN0IHNhbWVTaXRlID0gdHlwZW9mIG9wdC5zYW1lU2l0ZSA9PT0gJ3N0cmluZycgPyBvcHQuc2FtZVNpdGUudG9Mb3dlckNhc2UoKSA6IG9wdC5zYW1lU2l0ZTtcbiAgICBzd2l0Y2ggKHNhbWVTaXRlKSB7XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1TdHJpY3QnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xheCc6XG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1MYXgnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmljdCc6XG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1TdHJpY3QnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIHNhbWVTaXRlIGlzIGludmFsaWQnKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdC5wYXJ0aXRpb25lZCkgc3RyICs9ICc7IFBhcnRpdGlvbmVkJztcbiAgcmV0dXJuIHN0cjtcbn07XG5jb25zdCBjb29raWUgPSB7XG4gIGNyZWF0ZShuYW1lLCB2YWx1ZSwgbWludXRlcywgZG9tYWluKSB7XG4gICAgbGV0IGNvb2tpZU9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHtcbiAgICAgIHBhdGg6ICcvJyxcbiAgICAgIHNhbWVTaXRlOiAnc3RyaWN0J1xuICAgIH07XG4gICAgaWYgKG1pbnV0ZXMpIHtcbiAgICAgIGNvb2tpZU9wdGlvbnMuZXhwaXJlcyA9IG5ldyBEYXRlKCk7XG4gICAgICBjb29raWVPcHRpb25zLmV4cGlyZXMuc2V0VGltZShjb29raWVPcHRpb25zLmV4cGlyZXMuZ2V0VGltZSgpICsgbWludXRlcyAqIDYwICogMTAwMCk7XG4gICAgfVxuICAgIGlmIChkb21haW4pIGNvb2tpZU9wdGlvbnMuZG9tYWluID0gZG9tYWluO1xuICAgIGRvY3VtZW50LmNvb2tpZSA9IHNlcmlhbGl6ZUNvb2tpZShuYW1lLCB2YWx1ZSwgY29va2llT3B0aW9ucyk7XG4gIH0sXG4gIHJlYWQobmFtZSkge1xuICAgIGNvbnN0IG5hbWVFUSA9IGAke25hbWV9PWA7XG4gICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYyA9IGNhW2ldO1xuICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XG4gICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZW1vdmUobmFtZSwgZG9tYWluKSB7XG4gICAgdGhpcy5jcmVhdGUobmFtZSwgJycsIC0xLCBkb21haW4pO1xuICB9XG59O1xudmFyIGNvb2tpZSQxID0ge1xuICBuYW1lOiAnY29va2llJyxcbiAgLy8gRGVjb25zdHJ1Y3QgdGhlIG9wdGlvbnMgb2JqZWN0IGFuZCBleHRyYWN0IHRoZSBsb29rdXBDb29raWUgcHJvcGVydHlcbiAgbG9va3VwKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgbG9va3VwQ29va2llXG4gICAgfSA9IF9yZWY7XG4gICAgaWYgKGxvb2t1cENvb2tpZSAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gY29va2llLnJlYWQobG9va3VwQ29va2llKSB8fCB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0sXG4gIC8vIERlY29uc3RydWN0IHRoZSBvcHRpb25zIG9iamVjdCBhbmQgZXh0cmFjdCB0aGUgbG9va3VwQ29va2llLCBjb29raWVNaW51dGVzLCBjb29raWVEb21haW4sIGFuZCBjb29raWVPcHRpb25zIHByb3BlcnRpZXNcbiAgY2FjaGVVc2VyTGFuZ3VhZ2UobG5nLCBfcmVmMikge1xuICAgIGxldCB7XG4gICAgICBsb29rdXBDb29raWUsXG4gICAgICBjb29raWVNaW51dGVzLFxuICAgICAgY29va2llRG9tYWluLFxuICAgICAgY29va2llT3B0aW9uc1xuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAobG9va3VwQ29va2llICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvb2tpZS5jcmVhdGUobG9va3VwQ29va2llLCBsbmcsIGNvb2tpZU1pbnV0ZXMsIGNvb2tpZURvbWFpbiwgY29va2llT3B0aW9ucyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcXVlcnlzdHJpbmcgPSB7XG4gIG5hbWU6ICdxdWVyeXN0cmluZycsXG4gIC8vIERlY29uc3RydWN0IHRoZSBvcHRpb25zIG9iamVjdCBhbmQgZXh0cmFjdCB0aGUgbG9va3VwUXVlcnlzdHJpbmcgcHJvcGVydHlcbiAgbG9va3VwKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgbG9va3VwUXVlcnlzdHJpbmdcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQgZm91bmQ7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZXQge1xuICAgICAgICBzZWFyY2hcbiAgICAgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgICBpZiAoIXdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggJiYgd2luZG93LmxvY2F0aW9uLmhhc2g/LmluZGV4T2YoJz8nKSA+IC0xKSB7XG4gICAgICAgIHNlYXJjaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZyh3aW5kb3cubG9jYXRpb24uaGFzaC5pbmRleE9mKCc/JykpO1xuICAgICAgfVxuICAgICAgY29uc3QgcXVlcnkgPSBzZWFyY2guc3Vic3RyaW5nKDEpO1xuICAgICAgY29uc3QgcGFyYW1zID0gcXVlcnkuc3BsaXQoJyYnKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHBhcmFtc1tpXS5pbmRleE9mKCc9Jyk7XG4gICAgICAgIGlmIChwb3MgPiAwKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gcGFyYW1zW2ldLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICAgIGlmIChrZXkgPT09IGxvb2t1cFF1ZXJ5c3RyaW5nKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHBhcmFtc1tpXS5zdWJzdHJpbmcocG9zICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxufTtcblxudmFyIGhhc2ggPSB7XG4gIG5hbWU6ICdoYXNoJyxcbiAgLy8gRGVjb25zdHJ1Y3QgdGhlIG9wdGlvbnMgb2JqZWN0IGFuZCBleHRyYWN0IHRoZSBsb29rdXBIYXNoIHByb3BlcnR5IGFuZCB0aGUgbG9va3VwRnJvbUhhc2hJbmRleCBwcm9wZXJ0eVxuICBsb29rdXAoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBsb29rdXBIYXNoLFxuICAgICAgbG9va3VwRnJvbUhhc2hJbmRleFxuICAgIH0gPSBfcmVmO1xuICAgIGxldCBmb3VuZDtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaGFzaFxuICAgICAgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgIGlmIChoYXNoICYmIGhhc2gubGVuZ3RoID4gMikge1xuICAgICAgICBjb25zdCBxdWVyeSA9IGhhc2guc3Vic3RyaW5nKDEpO1xuICAgICAgICBpZiAobG9va3VwSGFzaCkge1xuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHF1ZXJ5LnNwbGl0KCcmJyk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHBhcmFtc1tpXS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYXJhbXNbaV0uc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgICAgICAgICAgIGlmIChrZXkgPT09IGxvb2t1cEhhc2gpIHtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHBhcmFtc1tpXS5zdWJzdHJpbmcocG9zICsgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgICAgIGlmICghZm91bmQgJiYgbG9va3VwRnJvbUhhc2hJbmRleCA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBoYXNoLm1hdGNoKC9cXC8oW2EtekEtWi1dKikvZyk7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxhbmd1YWdlKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHR5cGVvZiBsb29rdXBGcm9tSGFzaEluZGV4ID09PSAnbnVtYmVyJyA/IGxvb2t1cEZyb21IYXNoSW5kZXggOiAwO1xuICAgICAgICAgIHJldHVybiBsYW5ndWFnZVtpbmRleF0/LnJlcGxhY2UoJy8nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9XG59O1xuXG5sZXQgaGFzTG9jYWxTdG9yYWdlU3VwcG9ydCA9IG51bGw7XG5jb25zdCBsb2NhbFN0b3JhZ2VBdmFpbGFibGUgPSAoKSA9PiB7XG4gIGlmIChoYXNMb2NhbFN0b3JhZ2VTdXBwb3J0ICE9PSBudWxsKSByZXR1cm4gaGFzTG9jYWxTdG9yYWdlU3VwcG9ydDtcbiAgdHJ5IHtcbiAgICBoYXNMb2NhbFN0b3JhZ2VTdXBwb3J0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2FsU3RvcmFnZSAhPT0gbnVsbDtcbiAgICBpZiAoIWhhc0xvY2FsU3RvcmFnZVN1cHBvcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGVzdEtleSA9ICdpMThuZXh0LnRyYW5zbGF0ZS5ib28nO1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0ZXN0S2V5LCAnZm9vJyk7XG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzTG9jYWxTdG9yYWdlU3VwcG9ydCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBoYXNMb2NhbFN0b3JhZ2VTdXBwb3J0O1xufTtcbnZhciBsb2NhbFN0b3JhZ2UgPSB7XG4gIG5hbWU6ICdsb2NhbFN0b3JhZ2UnLFxuICAvLyBEZWNvbnN0cnVjdCB0aGUgb3B0aW9ucyBvYmplY3QgYW5kIGV4dHJhY3QgdGhlIGxvb2t1cExvY2FsU3RvcmFnZSBwcm9wZXJ0eVxuICBsb29rdXAoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBsb29rdXBMb2NhbFN0b3JhZ2VcbiAgICB9ID0gX3JlZjtcbiAgICBpZiAobG9va3VwTG9jYWxTdG9yYWdlICYmIGxvY2FsU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGxvb2t1cExvY2FsU3RvcmFnZSkgfHwgdW5kZWZpbmVkOyAvLyBVbmRlZmluZWQgZW5zdXJlcyB0eXBlIGNvbnNpc3RlbmN5IHdpdGggdGhlIHByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBmdW5jdGlvblxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxuICAvLyBEZWNvbnN0cnVjdCB0aGUgb3B0aW9ucyBvYmplY3QgYW5kIGV4dHJhY3QgdGhlIGxvb2t1cExvY2FsU3RvcmFnZSBwcm9wZXJ0eVxuICBjYWNoZVVzZXJMYW5ndWFnZShsbmcsIF9yZWYyKSB7XG4gICAgbGV0IHtcbiAgICAgIGxvb2t1cExvY2FsU3RvcmFnZVxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAobG9va3VwTG9jYWxTdG9yYWdlICYmIGxvY2FsU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0obG9va3VwTG9jYWxTdG9yYWdlLCBsbmcpO1xuICAgIH1cbiAgfVxufTtcblxubGV0IGhhc1Nlc3Npb25TdG9yYWdlU3VwcG9ydCA9IG51bGw7XG5jb25zdCBzZXNzaW9uU3RvcmFnZUF2YWlsYWJsZSA9ICgpID0+IHtcbiAgaWYgKGhhc1Nlc3Npb25TdG9yYWdlU3VwcG9ydCAhPT0gbnVsbCkgcmV0dXJuIGhhc1Nlc3Npb25TdG9yYWdlU3VwcG9ydDtcbiAgdHJ5IHtcbiAgICBoYXNTZXNzaW9uU3RvcmFnZVN1cHBvcnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UgIT09IG51bGw7XG4gICAgaWYgKCFoYXNTZXNzaW9uU3RvcmFnZVN1cHBvcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGVzdEtleSA9ICdpMThuZXh0LnRyYW5zbGF0ZS5ib28nO1xuICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHRlc3RLZXksICdmb28nKTtcbiAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0S2V5KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nlc3Npb25TdG9yYWdlU3VwcG9ydCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBoYXNTZXNzaW9uU3RvcmFnZVN1cHBvcnQ7XG59O1xudmFyIHNlc3Npb25TdG9yYWdlID0ge1xuICBuYW1lOiAnc2Vzc2lvblN0b3JhZ2UnLFxuICBsb29rdXAoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBsb29rdXBTZXNzaW9uU3RvcmFnZVxuICAgIH0gPSBfcmVmO1xuICAgIGlmIChsb29rdXBTZXNzaW9uU3RvcmFnZSAmJiBzZXNzaW9uU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICByZXR1cm4gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0obG9va3VwU2Vzc2lvblN0b3JhZ2UpIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSxcbiAgY2FjaGVVc2VyTGFuZ3VhZ2UobG5nLCBfcmVmMikge1xuICAgIGxldCB7XG4gICAgICBsb29rdXBTZXNzaW9uU3RvcmFnZVxuICAgIH0gPSBfcmVmMjtcbiAgICBpZiAobG9va3VwU2Vzc2lvblN0b3JhZ2UgJiYgc2Vzc2lvblN0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0obG9va3VwU2Vzc2lvblN0b3JhZ2UsIGxuZyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgbmF2aWdhdG9yJDEgPSB7XG4gIG5hbWU6ICduYXZpZ2F0b3InLFxuICBsb29rdXAob3B0aW9ucykge1xuICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxhbmd1YWdlcyxcbiAgICAgICAgdXNlckxhbmd1YWdlLFxuICAgICAgICBsYW5ndWFnZVxuICAgICAgfSA9IG5hdmlnYXRvcjtcbiAgICAgIGlmIChsYW5ndWFnZXMpIHtcbiAgICAgICAgLy8gY2hyb21lIG9ubHk7IG5vdCBhbiBhcnJheSwgc28gY2FuJ3QgdXNlIC5wdXNoLmFwcGx5IGluc3RlYWQgb2YgaXRlcmF0aW5nXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFuZ3VhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZm91bmQucHVzaChsYW5ndWFnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXNlckxhbmd1YWdlKSB7XG4gICAgICAgIGZvdW5kLnB1c2godXNlckxhbmd1YWdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgICBmb3VuZC5wdXNoKGxhbmd1YWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kLmxlbmd0aCA+IDAgPyBmb3VuZCA6IHVuZGVmaW5lZDtcbiAgfVxufTtcblxudmFyIGh0bWxUYWcgPSB7XG4gIG5hbWU6ICdodG1sVGFnJyxcbiAgLy8gRGVjb25zdHJ1Y3QgdGhlIG9wdGlvbnMgb2JqZWN0IGFuZCBleHRyYWN0IHRoZSBodG1sVGFnIHByb3BlcnR5XG4gIGxvb2t1cChfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIGh0bWxUYWdcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQgZm91bmQ7XG4gICAgY29uc3QgaW50ZXJuYWxIdG1sVGFnID0gaHRtbFRhZyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IG51bGwpO1xuICAgIGlmIChpbnRlcm5hbEh0bWxUYWcgJiYgdHlwZW9mIGludGVybmFsSHRtbFRhZy5nZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvdW5kID0gaW50ZXJuYWxIdG1sVGFnLmdldEF0dHJpYnV0ZSgnbGFuZycpO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbn07XG5cbnZhciBwYXRoID0ge1xuICBuYW1lOiAncGF0aCcsXG4gIC8vIERlY29uc3RydWN0IHRoZSBvcHRpb25zIG9iamVjdCBhbmQgZXh0cmFjdCB0aGUgbG9va3VwRnJvbVBhdGhJbmRleCBwcm9wZXJ0eVxuICBsb29rdXAoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBsb29rdXBGcm9tUGF0aEluZGV4XG4gICAgfSA9IF9yZWY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxhbmd1YWdlID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKC9cXC8oW2EtekEtWi1dKikvZyk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGxhbmd1YWdlKSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBjb25zdCBpbmRleCA9IHR5cGVvZiBsb29rdXBGcm9tUGF0aEluZGV4ID09PSAnbnVtYmVyJyA/IGxvb2t1cEZyb21QYXRoSW5kZXggOiAwO1xuICAgIHJldHVybiBsYW5ndWFnZVtpbmRleF0/LnJlcGxhY2UoJy8nLCAnJyk7XG4gIH1cbn07XG5cbnZhciBzdWJkb21haW4gPSB7XG4gIG5hbWU6ICdzdWJkb21haW4nLFxuICBsb29rdXAoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBsb29rdXBGcm9tU3ViZG9tYWluSW5kZXhcbiAgICB9ID0gX3JlZjtcbiAgICAvLyBJZiBnaXZlbiBnZXQgdGhlIHN1YmRvbWFpbiBpbmRleCBlbHNlIDFcbiAgICBjb25zdCBpbnRlcm5hbExvb2t1cEZyb21TdWJkb21haW5JbmRleCA9IHR5cGVvZiBsb29rdXBGcm9tU3ViZG9tYWluSW5kZXggPT09ICdudW1iZXInID8gbG9va3VwRnJvbVN1YmRvbWFpbkluZGV4ICsgMSA6IDE7XG4gICAgLy8gZ2V0IGFsbCBtYXRjaGVzIGlmIHdpbmRvdy5sb2NhdGlvbi4gaXMgZXhpc3RpbmdcbiAgICAvLyBmaXJzdCBpdGVtIG9mIG1hdGNoIGlzIHRoZSBtYXRjaCBpdHNlbGYgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIGZpcnN0IGdyb3VwIG1hdGNoIHdoaWNoIHNob3VsZCBiZSB0aGUgZmlyc3Qgc3ViZG9tYWluIG1hdGNoXG4gICAgLy8gaXMgdGhlIGhvc3RuYW1lIG5vIHB1YmxpYyBkb21haW4gZ2V0IHRoZSBvciBvcHRpb24gb2YgbG9jYWxob3N0XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24/Lmhvc3RuYW1lPy5tYXRjaCgvXihcXHd7Miw1fSlcXC4oKFthLXowLTktXXsxLDYzfVxcLlthLXpdezIsNn0pfGxvY2FsaG9zdCkvaSk7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBtYXRjaCAobnVsbCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghbGFuZ3VhZ2UpIHJldHVybiB1bmRlZmluZWQ7XG4gICAgLy8gcmV0dXJuIHRoZSBnaXZlbiBncm91cCBtYXRjaFxuICAgIHJldHVybiBsYW5ndWFnZVtpbnRlcm5hbExvb2t1cEZyb21TdWJkb21haW5JbmRleF07XG4gIH1cbn07XG5cbi8vIHNvbWUgZW52aXJvbm1lbnRzLCB0aHJvd3Mgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuY29va2llXG5sZXQgY2FuQ29va2llcyA9IGZhbHNlO1xudHJ5IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICBkb2N1bWVudC5jb29raWU7XG4gIGNhbkNvb2tpZXMgPSB0cnVlO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbn0gY2F0Y2ggKGUpIHt9XG5jb25zdCBvcmRlciA9IFsncXVlcnlzdHJpbmcnLCAnY29va2llJywgJ2xvY2FsU3RvcmFnZScsICdzZXNzaW9uU3RvcmFnZScsICduYXZpZ2F0b3InLCAnaHRtbFRhZyddO1xuaWYgKCFjYW5Db29raWVzKSBvcmRlci5zcGxpY2UoMSwgMSk7XG5jb25zdCBnZXREZWZhdWx0cyA9ICgpID0+ICh7XG4gIG9yZGVyLFxuICBsb29rdXBRdWVyeXN0cmluZzogJ2xuZycsXG4gIGxvb2t1cENvb2tpZTogJ2kxOG5leHQnLFxuICBsb29rdXBMb2NhbFN0b3JhZ2U6ICdpMThuZXh0TG5nJyxcbiAgbG9va3VwU2Vzc2lvblN0b3JhZ2U6ICdpMThuZXh0TG5nJyxcbiAgLy8gY2FjaGUgdXNlciBsYW5ndWFnZVxuICBjYWNoZXM6IFsnbG9jYWxTdG9yYWdlJ10sXG4gIGV4Y2x1ZGVDYWNoZUZvcjogWydjaW1vZGUnXSxcbiAgLy8gY29va2llTWludXRlczogMTAsXG4gIC8vIGNvb2tpZURvbWFpbjogJ215RG9tYWluJ1xuXG4gIGNvbnZlcnREZXRlY3RlZExhbmd1YWdlOiBsID0+IGxcbn0pO1xuY2xhc3MgQnJvd3NlciB7XG4gIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMudHlwZSA9ICdsYW5ndWFnZURldGVjdG9yJztcbiAgICB0aGlzLmRldGVjdG9ycyA9IHt9O1xuICAgIHRoaXMuaW5pdChzZXJ2aWNlcywgb3B0aW9ucyk7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBsZXQgc2VydmljZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHtcbiAgICAgIGxhbmd1YWdlVXRpbHM6IHt9XG4gICAgfTtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgbGV0IGkxOG5PcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB0aGlzLnNlcnZpY2VzID0gc2VydmljZXM7XG4gICAgdGhpcy5vcHRpb25zID0gZGVmYXVsdHMob3B0aW9ucywgdGhpcy5vcHRpb25zIHx8IHt9LCBnZXREZWZhdWx0cygpKTtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5jb252ZXJ0RGV0ZWN0ZWRMYW5ndWFnZSA9PT0gJ3N0cmluZycgJiYgdGhpcy5vcHRpb25zLmNvbnZlcnREZXRlY3RlZExhbmd1YWdlLmluZGV4T2YoJzE1ODk3JykgPiAtMSkge1xuICAgICAgdGhpcy5vcHRpb25zLmNvbnZlcnREZXRlY3RlZExhbmd1YWdlID0gbCA9PiBsLnJlcGxhY2UoJy0nLCAnXycpO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb29rdXBGcm9tVXJsSW5kZXgpIHRoaXMub3B0aW9ucy5sb29rdXBGcm9tUGF0aEluZGV4ID0gdGhpcy5vcHRpb25zLmxvb2t1cEZyb21VcmxJbmRleDtcbiAgICB0aGlzLmkxOG5PcHRpb25zID0gaTE4bk9wdGlvbnM7XG4gICAgdGhpcy5hZGREZXRlY3Rvcihjb29raWUkMSk7XG4gICAgdGhpcy5hZGREZXRlY3RvcihxdWVyeXN0cmluZyk7XG4gICAgdGhpcy5hZGREZXRlY3Rvcihsb2NhbFN0b3JhZ2UpO1xuICAgIHRoaXMuYWRkRGV0ZWN0b3Ioc2Vzc2lvblN0b3JhZ2UpO1xuICAgIHRoaXMuYWRkRGV0ZWN0b3IobmF2aWdhdG9yJDEpO1xuICAgIHRoaXMuYWRkRGV0ZWN0b3IoaHRtbFRhZyk7XG4gICAgdGhpcy5hZGREZXRlY3RvcihwYXRoKTtcbiAgICB0aGlzLmFkZERldGVjdG9yKHN1YmRvbWFpbik7XG4gICAgdGhpcy5hZGREZXRlY3RvcihoYXNoKTtcbiAgfVxuICBhZGREZXRlY3RvcihkZXRlY3Rvcikge1xuICAgIHRoaXMuZGV0ZWN0b3JzW2RldGVjdG9yLm5hbWVdID0gZGV0ZWN0b3I7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGV0ZWN0KCkge1xuICAgIGxldCBkZXRlY3Rpb25PcmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLm9yZGVyO1xuICAgIGxldCBkZXRlY3RlZCA9IFtdO1xuICAgIGRldGVjdGlvbk9yZGVyLmZvckVhY2goZGV0ZWN0b3JOYW1lID0+IHtcbiAgICAgIGlmICh0aGlzLmRldGVjdG9yc1tkZXRlY3Rvck5hbWVdKSB7XG4gICAgICAgIGxldCBsb29rdXAgPSB0aGlzLmRldGVjdG9yc1tkZXRlY3Rvck5hbWVdLmxvb2t1cCh0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAobG9va3VwICYmIHR5cGVvZiBsb29rdXAgPT09ICdzdHJpbmcnKSBsb29rdXAgPSBbbG9va3VwXTtcbiAgICAgICAgaWYgKGxvb2t1cCkgZGV0ZWN0ZWQgPSBkZXRlY3RlZC5jb25jYXQobG9va3VwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkZXRlY3RlZCA9IGRldGVjdGVkLmZpbHRlcihkID0+IGQgIT09IHVuZGVmaW5lZCAmJiBkICE9PSBudWxsICYmICFoYXNYU1MoZCkpLm1hcChkID0+IHRoaXMub3B0aW9ucy5jb252ZXJ0RGV0ZWN0ZWRMYW5ndWFnZShkKSk7XG4gICAgaWYgKHRoaXMuc2VydmljZXMgJiYgdGhpcy5zZXJ2aWNlcy5sYW5ndWFnZVV0aWxzICYmIHRoaXMuc2VydmljZXMubGFuZ3VhZ2VVdGlscy5nZXRCZXN0TWF0Y2hGcm9tQ29kZXMpIHJldHVybiBkZXRlY3RlZDsgLy8gbmV3IGkxOG5leHQgdjE5LjUuMFxuICAgIHJldHVybiBkZXRlY3RlZC5sZW5ndGggPiAwID8gZGV0ZWN0ZWRbMF0gOiBudWxsOyAvLyBhIGxpdHRsZSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIH1cbiAgY2FjaGVVc2VyTGFuZ3VhZ2UobG5nKSB7XG4gICAgbGV0IGNhY2hlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5vcHRpb25zLmNhY2hlcztcbiAgICBpZiAoIWNhY2hlcykgcmV0dXJuO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZXhjbHVkZUNhY2hlRm9yICYmIHRoaXMub3B0aW9ucy5leGNsdWRlQ2FjaGVGb3IuaW5kZXhPZihsbmcpID4gLTEpIHJldHVybjtcbiAgICBjYWNoZXMuZm9yRWFjaChjYWNoZU5hbWUgPT4ge1xuICAgICAgaWYgKHRoaXMuZGV0ZWN0b3JzW2NhY2hlTmFtZV0pIHRoaXMuZGV0ZWN0b3JzW2NhY2hlTmFtZV0uY2FjaGVVc2VyTGFuZ3VhZ2UobG5nLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG59XG5Ccm93c2VyLnR5cGUgPSAnbGFuZ3VhZ2VEZXRlY3Rvcic7XG5cbmV4cG9ydCB7IEJyb3dzZXIgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbInNsaWNlIiwiZm9yRWFjaCIsImRlZmF1bHRzIiwib2JqIiwiY2FsbCIsImFyZ3VtZW50cyIsInNvdXJjZSIsInByb3AiLCJ1bmRlZmluZWQiLCJoYXNYU1MiLCJpbnB1dCIsInhzc1BhdHRlcm5zIiwic29tZSIsInBhdHRlcm4iLCJ0ZXN0IiwiZmllbGRDb250ZW50UmVnRXhwIiwic2VyaWFsaXplQ29va2llIiwibmFtZSIsInZhbCIsIm9wdGlvbnMiLCJsZW5ndGgiLCJwYXRoIiwib3B0IiwidmFsdWUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzdHIiLCJtYXhBZ2UiLCJOdW1iZXIiLCJpc05hTiIsIkVycm9yIiwiTWF0aCIsImZsb29yIiwiZG9tYWluIiwiVHlwZUVycm9yIiwiZXhwaXJlcyIsInRvVVRDU3RyaW5nIiwiaHR0cE9ubHkiLCJzZWN1cmUiLCJzYW1lU2l0ZSIsInRvTG93ZXJDYXNlIiwicGFydGl0aW9uZWQiLCJjb29raWUiLCJjcmVhdGUiLCJtaW51dGVzIiwiY29va2llT3B0aW9ucyIsIkRhdGUiLCJzZXRUaW1lIiwiZ2V0VGltZSIsImRvY3VtZW50IiwicmVhZCIsIm5hbWVFUSIsImNhIiwic3BsaXQiLCJpIiwiYyIsImNoYXJBdCIsInN1YnN0cmluZyIsImluZGV4T2YiLCJyZW1vdmUiLCJjb29raWUkMSIsImxvb2t1cCIsIl9yZWYiLCJsb29rdXBDb29raWUiLCJjYWNoZVVzZXJMYW5ndWFnZSIsImxuZyIsIl9yZWYyIiwiY29va2llTWludXRlcyIsImNvb2tpZURvbWFpbiIsInF1ZXJ5c3RyaW5nIiwibG9va3VwUXVlcnlzdHJpbmciLCJmb3VuZCIsInNlYXJjaCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaGFzaCIsInF1ZXJ5IiwicGFyYW1zIiwicG9zIiwia2V5IiwibG9va3VwSGFzaCIsImxvb2t1cEZyb21IYXNoSW5kZXgiLCJsYW5ndWFnZSIsIm1hdGNoIiwiQXJyYXkiLCJpc0FycmF5IiwiaW5kZXgiLCJyZXBsYWNlIiwiaGFzTG9jYWxTdG9yYWdlU3VwcG9ydCIsImxvY2FsU3RvcmFnZUF2YWlsYWJsZSIsImxvY2FsU3RvcmFnZSIsInRlc3RLZXkiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImUiLCJsb29rdXBMb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiaGFzU2Vzc2lvblN0b3JhZ2VTdXBwb3J0Iiwic2Vzc2lvblN0b3JhZ2VBdmFpbGFibGUiLCJzZXNzaW9uU3RvcmFnZSIsImxvb2t1cFNlc3Npb25TdG9yYWdlIiwibmF2aWdhdG9yJDEiLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZXMiLCJ1c2VyTGFuZ3VhZ2UiLCJwdXNoIiwiaHRtbFRhZyIsImludGVybmFsSHRtbFRhZyIsImRvY3VtZW50RWxlbWVudCIsImdldEF0dHJpYnV0ZSIsImxvb2t1cEZyb21QYXRoSW5kZXgiLCJwYXRobmFtZSIsInN1YmRvbWFpbiIsImxvb2t1cEZyb21TdWJkb21haW5JbmRleCIsImludGVybmFsTG9va3VwRnJvbVN1YmRvbWFpbkluZGV4IiwiaG9zdG5hbWUiLCJjYW5Db29raWVzIiwib3JkZXIiLCJzcGxpY2UiLCJnZXREZWZhdWx0cyIsImNhY2hlcyIsImV4Y2x1ZGVDYWNoZUZvciIsImNvbnZlcnREZXRlY3RlZExhbmd1YWdlIiwibCIsIkJyb3dzZXIiLCJjb25zdHJ1Y3RvciIsInNlcnZpY2VzIiwidHlwZSIsImRldGVjdG9ycyIsImluaXQiLCJsYW5ndWFnZVV0aWxzIiwiaTE4bk9wdGlvbnMiLCJsb29rdXBGcm9tVXJsSW5kZXgiLCJhZGREZXRlY3RvciIsImRldGVjdG9yIiwiZGV0ZWN0IiwiZGV0ZWN0aW9uT3JkZXIiLCJkZXRlY3RlZCIsImRldGVjdG9yTmFtZSIsImNvbmNhdCIsImZpbHRlciIsImQiLCJtYXAiLCJnZXRCZXN0TWF0Y2hGcm9tQ29kZXMiLCJjYWNoZU5hbWUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js\n");

/***/ })

};
;